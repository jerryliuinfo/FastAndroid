def initModuleCompile() {
    Properties properties = new Properties();
    File file = new File(rootDir.getAbsolutePath() + "/module.properties")
    properties.load(file.newDataInputStream())
    Iterator itr = properties.entrySet().iterator();
    while (itr.hasNext()) {
        Map.Entry e = (Map.Entry) itr.next();
        String key = e.getKey();
        ext.setProperty(key, e.getValue());
        println("setting_config.gradle key = ${key}, value = ${e.getValue()}")
    }
}

initModuleCompile()

gradle.addListener new TaskTimeMonitor()

if (isLibraryDebug.toBoolean() || isAllDebug.toBoolean()) {
    include ':library'
    println("include library \n")
}else {
    println("not include library \n")
}


class TaskTimeMonitor implements TaskExecutionListener, BuildListener {
    private final Map<Task, Timing> timings = Collections.synchronizedMap(new LinkedHashMap())

    @Override
    void beforeExecute(Task task) {
        timings.put(task, new Timing(task))
    }

    @Override
    void afterExecute(Task task, TaskState taskState) {
        Timing timing = timings.get(task)

        if (timing) {
            timing.complete()

            if (timing.report) {
                task.project.logger.warn "${timing.path} took ${timing.ms}ms"
            }
        }
    }

    @Override
    void buildFinished(BuildResult result) {
        boolean reportWhenFinished = timings.values().find { Timing timing -> timing.report }

        if (reportWhenFinished) {
            println "Task timings over threshold:\n"
            Comparator<Timing> comparator = Timing.orderByMsFor(0)
            timings.values().toSorted(comparator).each { Timing timing ->
                if (timing.report) {
                    printf "cost %7sms  %s\n", [timing.ms, timing.path]
                }
            }
        }
        timings.clear()
    }

    @Override
    void buildStarted(Gradle gradle) {}

    @Override
    void projectsEvaluated(Gradle gradle) {}

    @Override
    void projectsLoaded(Gradle gradle) {}

    @Override
    void settingsEvaluated(Settings settings) {}

    private static class Timing {

        private static final ORDER_BY_MS_DESC = new OrderBy<Timing>([{ -it.ms }])
        private static final ORDER_BY_MS_ASC = new OrderBy<Timing>([{ it.ms }])
        private static final ORDER_BY_NONE = new OrderBy();

        private final Task task
        private final Clock clock
        private boolean report
        private long ms

        Timing(Task task) {
            this.task = task
            this.clock = new Clock()
        }

        String getPath() {
            task.path
        }

        void complete() {
            ms = clock.timeInMs
            report = (ms > getReportAboveForTask())
        }

        private long getReportAboveForTask() {
            return 100L;
        }

        static Comparator<Timing> orderByMsFor(int sortOrder) {
            switch (sortOrder) {
                case 0:
                    return ORDER_BY_MS_ASC;
                    break;
                case 1:
                    return ORDER_BY_MS_DESC;
                    break;
                default:
                    return ORDER_BY_NONE;
                    break;
            }
        }
    }
}
